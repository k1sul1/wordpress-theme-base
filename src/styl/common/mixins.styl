/**
 * px => rem mixin
 */
r(value) {
  u = unit(value);

  if (u is 'px') {
    return unit(value/16, 'rem')
  } else {
    return unit(value, u)
  }
}

/**
 * A monster created as an attempt to have a single place for positioning elements
 * Might not live long, might live forever.
 * We'll see.
 */
generatePositions(selector, method = 'position') {
  if (method == 'position') {
    {selector}.k1-pos {
      &--leftTop {
        left: r(20px)
        top: r(20px)
      }

      &--centerTop {
        margin-left: auto
        margin-right: auto
        top: r(20px)
      }

      &--rightTop {
        right: r(20px)
        top: r(20px)
      }

      &--leftCenter {
        top: 50%
        transform: translateY(-50%)
        left: r(20px)
      }

      &--centerCenter {
        top: 50%
        left: 50%
        transform: translateY(-50%) translateX(-50%)
      }

      &--rightCenter {
        top: 50%
        transform: translateY(-50%)
        right: r(20px)
      }

      &--leftBottom {
        left: r(20px)
        bottom: r(20px)
      }

      &--centerBottom {
        margin-left: auto
        margin-right: auto
        bottom: r(20px)
      }

      &--rightBottom {
        right: r(20px)
        bottom: r(20px)
      }
    }
  } else if (method == 'background-position') {
    {selector}.k1-pos {
      &--leftTop {
        background-position: left top
      }

      &--centerTop {
        background-position: center top
      }

      &--rightTop {
        background-position: right top
      }

      &--leftCenter {
        background-position: left center
      }

      &--centerCenter {
        background-position: center center
      }

      &--rightCenter {
        background-position: right center
      }

      &--leftBottom {
        background-position: left bottom
      }

      &--centerBottom {
        background-position: center bottom
      }

      &--rightBottom {
        background-position: right bottom
      }
    }
  } else if (method == 'object-position') {
    {selector}.k1-pos {
      &--leftTop {
        object-position: left top
      }

      &--centerTop {
        object-position: center top
      }

      &--rightTop {
        object-position: right top
      }

      &--leftCenter {
        object-position: left center
      }

      &--centerCenter {
        object-position: center center
      }

      &--rightCenter {
        object-position: right center
      }

      &--leftBottom {
        object-position: left bottom
      }

      &--centerBottom {
        object-position: center bottom
      }

      &--rightBottom {
        object-position: right bottom
      }
    }
  } else if (method == 'flex') {
    // Assuming flex-flow: row nowrap

    {selector}.k1-pos {
      &--leftTop {
        align-items: flex-start
        justify-content: flex-start
      }

      &--centerTop {
        align-items: flex-start
        justify-content: center
      }

      &--rightTop {
        align-items: flex-start
        justify-content: flex-end
      }

      &--leftCenter {
        align-items: center
        justify-content: flex-start
      }

      &--centerCenter {
        align-items: center
        justify-content: center
      }

      &--rightCenter {
        align-items: center
        justify-content: flex-end
      }

      &--leftBottom {
        align-items: flex-end
        justify-content: flex-start
      }

      &--centerBottom {
        align-items: flex-end
        justify-content: center
      }

      &--rightBottom {
        align-items: flex-end
        justify-content: flex-end
      }
    }
  }
}

/**
 * Mixin used to turn any element into an element only visible to screen-readers.
 * Use .sr-text class instead if possible.
 */
srText() {
  clip: rect(1px, 1px, 1px, 1px)
  position: absolute !important
  height: 1px
  width: 1px
  overflow: hidden
  word-wrap: normal !important
  // Many screen reader and browser combinations announce broken words as they would appear visually.

  &:focus {
    background-color: #f1f1f1
    border-radius: 3px
    box-shadow: 0 0 2px 2px rgba(0, 0, 0, 0.6)
    clip: auto !important
    color: #21759b
    display: block
    font-size: 14px
    font-size: 0.875rem
    font-weight: bold
    height: auto
    left: 5px
    line-height: normal
    padding: 15px 23px 14px
    text-decoration: none
    top: 5px
    width: auto
    z-index: 100000 // Above toolbar.
  }
}

/**
 * Media query mixins. Instead of raw media queries, prefer using these.
 * Customize if necessary.
 * https://css-tricks.com/logic-in-media-queries/
 */

forDesktop() {
  @media (min-width: bp.lg) {
    {block}
  }
}

/**
 * Tablet media queries often work for phones too, so styles will be applied
 * to mobile devices as well by default.
 */
forTablet(only = false) {
  if (only == false) {
    @media (max-width: bp.md) {
      {block}
    }
  } else {
    @media (min-width: bp.md) and (max-width: bp.lg) {
      {block}
    }
  }
}

forPhone() {
  @media (min-width: 0px) and (max-width: bp.sm) {
    {block}
  }
}

forTinyPhone() {
  @media (max-width: bp.xs) {
    {block}
  }
}

// Match mobile devices (phones and tablets) in landscape
// Larger breakpoints are *most likely* users that expect
// a desktop experience due to their screen size
forLandscape() {
  @media (orientation:landscape) and (max-width: bp.md) {
    {block}
  }
}

/**
 * Mixin used to autogenerate classes that can be applied from the GUI.
 * You're probably doing something wrong if you're using this in your code.
 *
 * I haven't figured out a way to automate this; manual work
 */
hideForBP(bp) {
  if (bp == 'xs') {
    +forTinyPhone() {
      display: none !important
    }
  } else if (bp == 'sm') {
    +forPhone() {
      display: none !important
    }
  } else if (bp == 'md') {
    +forTablet(true) {
      display: none !important
    }
  } else if (bp == 'lg') {
    +forDesktop() {
      display: none !important
    }
  }
}
